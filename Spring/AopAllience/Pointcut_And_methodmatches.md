###
스프링의 포인트컷 모델은 advice 유형과 독립적으로 포인트컷을 재사용할 수 있게 해줍니다. 동일한 포인트컷으로 다양한 어드바이스를 타겟팅할 수 있습니다.

org.springframework.aop.Pointcut 인터페이스는 특정 클래스와 메서드를 타겟으로 어드바이스를 지정하기 위해 사용하는 핵심 인터페이스입니다. 전체 인터페이스는 다음과 같습니다:


##  다시 알아보는 Pointcut 개념

Spring에서 **Pointcut**은 특정 메서드나 클래스에 어드바이스를 적용할 위치를 지정하는 방법입니다. 이를 통해 우리는 다양한 어드바이스(Advice)를 동일한 포인트컷(Pointcut)으로 타겟팅할 수 있습니다.


### Pointcut 인터페이스

`Pointcut` 인터페이스는 어드바이스를 어떤 클래스와 메서드에 적용할지 정의하는 데 사용됩니다. 이 인터페이스는 두 가지 핵심 메서드를 가지고 있습니다:

```java
public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();
}
```

이 인터페이스를 통해 클래스와 메서드 매칭 부분을 독립적으로 재사용할 수 있습니다. 또한 다양한 메서드 매처와 결합하여 복잡한 조합 작업을 수행할 수도 있습니다.

### ClassFilter 인터페이스

`ClassFilter` 인터페이스는 포인트컷이 특정 타겟 클래스 집합으로 제한되도록 해줍니다. 이 인터페이스는 다음과 같이 정의됩니다:

```java
public interface ClassFilter {

    boolean matches(Class<?> clazz);
}
```

`matches()` 메서드가 항상 `true`를 반환한다면 모든 타겟 클래스가 일치하게 됩니다. 즉, 모든 클래스가 매칭될 수 있도록 설정할 수 있습니다.

## MethodMatcher 인터페이스
포인트컷에서 메서드 매칭은 일반적으로 클래스 매칭보다 더 중요합니다. Spring AOP에서 메서드 단위로 포인트컷을 정의하는 데 사용되는 중요한 인터페이스가 바로 `MethodMatcher`입니다.


이 메서드들은 각각 다음과 같은 역할을 합니다:

1. **matches(Method m, Class<?> targetClass)**:
   - 특정 클래스의 메서드가 포인트컷의 조건에 맞는지 검사합니다.
   - AOP 프록시가 생성될 때 한 번 실행되며, 이 메서드가 `true`를 반환하면 해당 메서드에 어드바이스가 적용됩니다.
   - 이 과정은 정적 매칭(Static Matching)으로, 메서드 호출 시마다 매칭 로직을 반복할 필요가 없어 성능에 매우 유리합니다.

2. **isRuntime()**:
   - 런타임 시점에서 추가적인 매칭 로직이 필요한지를 결정합니다.
   - `true`를 반환하면, 메서드 호출 시마다 세 개의 아규먼트를 받는 `matches(Method m, Class<?> targetClass, Object... args)` 메서드가 호출됩니다.
   - `false`를 반환하면, 메서드 호출 시 추가적인 매칭이 수행되지 않으며, 캐시된 결과를 사용합니다.

3. **matches(Method m, Class<?> targetClass, Object... args)**:
   - `isRuntime()`이 `true`일 때만 호출되며, 메서드의 실제 아규먼트(`args`)를 포함한 보다 세부적인 매칭을 수행합니다.
   - 이 메서드는 메서드 호출 시마다 실행되어 특정 아규먼트 값에 따라 포인트컷 매칭 여부를 동적으로 결정할 수 있습니다.

### 정적 매칭(Static Matching)과 런타임 매칭(Runtime Matching)

Spring AOP에서 메서드 매칭은 크게 두 가지 방식으로 이루어질 수 있습니다: 정적 매칭과 런타임 매칭입니다.

#### 정적 매칭 (Static Matching)
- **설명**: AOP 프록시가 생성될 때 수행되는 매칭입니다. 즉, 애플리케이션이 시작되거나 빈이 초기화될 때 특정 메서드가 포인트컷에 일치하는지 미리 결정됩니다.
- **장점**: 메서드 호출 시마다 매칭을 수행할 필요가 없기 때문에 성능이 더 좋습니다. `matches(Method m, Class<?> targetClass)` 메서드에서 매칭이 수행되고, 그 결과는 캐시됩니다.
- **적용 사례**: 메서드 이름이나 메서드가 속한 클래스와 같은 고정된 특성에 따라 어드바이스를 적용할 때 사용됩니다.

#### 런타임 매칭 (Runtime Matching)
- **설명**: 메서드가 호출될 때마다 아규먼트 값과 같은 동적인 특성을 기반으로 매칭을 수행합니다. 이 경우, 매 호출 시마다 `matches(Method m, Class<?> targetClass, Object... args)` 메서드가 실행됩니다.
- **단점**: 매번 매칭이 수행되므로, 성능에 부정적인 영향을 미칠 수 있습니다.
- **적용 사례**: 특정 아규먼트 값에 따라 어드바이스 적용 여부를 동적으로 결정해야 할 때 사용됩니다. 예를 들어, 메서드 아규먼트가 특정 값일 때만 로깅을 수행하도록 하는 경우가 있습니다.

### 포인트컷 캐싱의 중요성

정적 매칭을 사용할 경우, AOP 프레임워크가 AOP 프록시가 생성될 때 포인트컷 평가 결과를 캐시할 수 있습니다. 이를 통해 메서드 호출 시 매칭을 다시 수행할 필요가 없어 성능이 크게 개선될 수 있습니다.

## 결론

Spring AOP의 `MethodMatcher`와 `Pointcut` API는 매우 강력하면서도 유연하게 설계되어 있습니다. 정적 매칭을 통해 성능을 극대화하고, 필요에 따라 런타임 매칭을 활용하여 동적인 조건을 처리할 수 있습니다. 이와 같은 설계를 통해 Spring AOP는 다양한 시나리오에서 효율적으로 동작할 수 있습니다.

Spring AOP에서 포인트컷을 이해하고 활용하는 것은 어드바이스를 적절히 적용하고, 성능을 최적화하는 데 중요한 역할을 합니다. 가능하면 정적 매칭을 활용하여 AOP 프레임워크가 효율적으로 동작하도록 설계하는 것이 좋습니다.