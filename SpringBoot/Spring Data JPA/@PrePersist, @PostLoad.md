### @PrePersist

- `@PrePersist`는 **영속화되기 전에 호출되는 메소드**에 붙입니다. 즉, 엔티티가 처음 **`persist()`** 호출되어 영속성 컨텍스트에 들어가게 될 때, 데이터베이스에 저장되기 전에 `@PrePersist`가 붙은 메소드가 먼저 실행됩니다. 이때 주로 생성일이나 초기값 설정 등 데이터를 저장하기 전에 해야 할 작업들을 처리할 때 사용됩니다.

```java
@Entity
public class MyEntity {

    @PrePersist
    public void onPrePersist() {
        System.out.println("엔티티가 영속되기 전에 호출됩니다.");
    }
}

```

### @PostLoad

- `@PostLoad`는 **데이터가 1차 캐시로 로드된 후에 호출되는 메소드**입니다. 엔티티 매니저가 select 쿼리를 실행하여 데이터베이스에서 엔티티를 로드할 때, 그 엔티티가 1차 캐시에 저장된 후 `@PostLoad`가 붙은 메소드가 호출됩니다.

```java
@Entity
public class MyEntity {

    @PostLoad
    public void onPostLoad() {
        System.out.println("엔티티가 1차 캐시에 로드된 후 호출됩니다.");
    }
}

```

### 영속성 컨텍스트와 1차 캐시

- 엔티티 매니저를 통해 `select` 쿼리를 날렸을 때, 해당 엔티티가 **1차 캐시**(영속성 컨텍스트)에 없다면 데이터베이스에서 데이터를 가져옵니다.
- 가져온 데이터는 **엔티티 매니저에 의해** 영속성 컨텍스트에 **저장**되며, 이때 1차 캐시에 저장됩니다.
- 이후 1차 캐시에서 엔티티를 참조하게 되므로, 같은 트랜잭션 내에서 동일한 데이터를 조회할 때 데이터베이스를 다시 조회하지 않습니다.

이해를 돕기 위한 간단한 흐름은 다음과 같습니다:

1. 엔티티 매니저가 `select` 쿼리를 실행.
2. **1차 캐시에서 엔티티를 검색**.
3. 1차 캐시에 없으면 **데이터베이스에서 데이터를 조회**.
4. 조회된 엔티티를 **1차 캐시에 저장**.
5. 이후 `@PostLoad`가 붙은 메소드가 호출.