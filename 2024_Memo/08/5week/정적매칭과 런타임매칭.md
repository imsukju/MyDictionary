Spring AOP 예제를 `@Aspect`와 `@Component` 어노테이션을 사용하지 않고 직접 Proxy 패턴을 통해 구현하는 방식으로 만들어 보겠습니다. 이 방식에서는 AOP를 수동으로 설정하고, `AspectJ` 표현식 대신, 직접 인터페이스와 프록시 클래스를 만들어 사용합니다.

### 1. Service Interface와 구현 클래스

```java
package com.example.service;

public interface MyService {
    void performTask();
    void performAnotherTask();
}

package com.example.service;

public class MyServiceImpl implements MyService {

    @Override
    public void performTask() {
        System.out.println("Performing task...");
    }

    @Override
    public void performAnotherTask() {
        System.out.println("Performing another task...");
    }
}
```

### 2. 정적 매칭을 위한 Proxy 클래스

정적 매칭을 위해 프록시를 만들어, 모든 메서드 호출 전에 공통된 로직을 실행하도록 합니다.

```java
package com.example.proxy;

import com.example.service.MyService;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class MyServiceStaticProxy implements InvocationHandler {

    private final MyService target;

    public MyServiceStaticProxy(MyService target) {
        this.target = target;
    }

    public MyService createProxy() {
        return (MyService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                this
        );
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 정적 매칭: 모든 메서드에 대해 동일한 로직 실행
        System.out.println("Before method execution - static matching");
        return method.invoke(target, args);
    }
}
```

### 3. 런타임 매칭을 위한 Proxy 클래스

런타임 매칭을 위해 특정 조건에 따라 메서드 호출 전에 공통된 로직을 실행하도록 합니다.

```java
package com.example.proxy;

import com.example.service.MyService;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class MyServiceRuntimeProxy implements InvocationHandler {

    private final MyService target;

    public MyServiceRuntimeProxy(MyService target) {
        this.target = target;
    }

    public MyService createProxy() {
        return (MyService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                this
        );
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 런타임 매칭: 특정 조건에 따라 로직 실행 (예: 메서드 이름에 "perform"이 포함된 경우)
        if (method.getName().contains("perform")) {
            System.out.println("Before method execution - runtime matching");
        }
        return method.invoke(target, args);
    }
}
```

### 4. 사용 예제

이제 위의 프록시 클래스를 이용해 `MyService`를 사용하는 예제를 만들어 보겠습니다.

```java
package com.example;

import com.example.proxy.MyServiceRuntimeProxy;
import com.example.proxy.MyServiceStaticProxy;
import com.example.service.MyService;
import com.example.service.MyServiceImpl;

public class AopExampleApplication {

    public static void main(String[] args) {
        // 원본 서비스 객체
        MyService originalService = new MyServiceImpl();

        // 정적 매칭 프록시
        MyServiceStaticProxy staticProxyHandler = new MyServiceStaticProxy(originalService);
        MyService staticProxy = staticProxyHandler.createProxy();
        
        // 런타임 매칭 프록시
        MyServiceRuntimeProxy runtimeProxyHandler = new MyServiceRuntimeProxy(originalService);
        MyService runtimeProxy = runtimeProxyHandler.createProxy();

        // 정적 매칭 프록시 사용
        System.out.println("Static Proxy:");
        staticProxy.performTask();
        staticProxy.performAnotherTask();

        // 런타임 매칭 프록시 사용
        System.out.println("\nRuntime Proxy:");
        runtimeProxy.performTask();
        runtimeProxy.performAnotherTask();
    }
}
```

### 5. 결과

이 코드를 실행하면 다음과 같은 결과를 얻게 됩니다:

```
Static Proxy:
Before method execution - static matching
Performing task...
Before method execution - static matching
Performing another task...

Runtime Proxy:
Before method execution - runtime matching
Performing task...
Before method execution - runtime matching
Performing another task...
```

### 차이점 설명
- **정적 매칭:** `MyServiceStaticProxy`는 모든 메서드 호출 전에 동일한 `before` 로직을 실행합니다. 즉, 정적인 조건으로 모든 메서드에 대해 AOP를 적용합니다.
- **런타임 매칭:** `MyServiceRuntimeProxy`는 메서드 이름에 "perform"이 포함된 경우에만 `before` 로직을 실행합니다. 이는 런타임 조건에 따라 AOP를 적용하는 방식입니다.

이 방식에서는 Spring AOP의 자동화된 기능을 사용하지 않고, 직접 프록시 패턴을 통해 정적 및 런타임 매칭을 구현했습니다.