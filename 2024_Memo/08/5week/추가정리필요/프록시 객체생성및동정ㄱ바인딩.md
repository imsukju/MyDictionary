### AOP의 프록시 객체 생성 및 동적 바인딩 메커니즘 
어드바이스된 객체가 원래 특정 인터페이스나 클래스를 상속하지 않았음에도 불구하고 특정 인터페이스(예: `Lockable`)로 캐스팅이 가능한 이유는 **AOP의 프록시 객체 생성 및 동적 바인딩 메커니즘** 때문입니다. 이 메커니즘을 통해 AOP 프레임워크는 런타임에 원본 객체를 감싸는 프록시 객체를 생성하고, 이 프록시 객체가 추가적인 인터페이스를 구현하도록 할 수 있습니다.

다음은 이 동작 방식에 대한 자세한 설명입니다.

### **1. 프록시 객체의 역할**
- AOP(Aspect-Oriented Programming)에서는 핵심 비즈니스 로직과 횡단 관심사(예: 로깅, 트랜잭션 관리)를 분리하기 위해 **프록시 객체**를 생성합니다. 이 프록시 객체는 원본 객체를 감싸고, 추가적인 기능(어드바이스)을 제공하며, 클라이언트에게는 원본 객체와 동일한 방식으로 보입니다.
- 이 프록시 객체는 원본 객체의 메서드를 호출하기 전에 필요한 추가 작업을 수행할 수 있으며, 이와 동시에 **새로운 인터페이스를 구현**하도록 설정할 수 있습니다.

### **2. 프록시 객체가 추가 인터페이스를 구현하는 방법**
- **JDK 동적 프록시**: 자바의 `Proxy` 클래스를 사용하여 원본 객체가 구현한 인터페이스 외에도 추가적인 인터페이스를 프록시 객체가 구현할 수 있도록 합니다. 예를 들어, 원본 객체는 `Lockable` 인터페이스를 구현하지 않았더라도, 프록시 객체는 이 인터페이스를 구현할 수 있습니다.
- **CGLIB 프록시**: CGLIB는 클래스 상속을 이용하여 프록시 객체를 생성합니다. 원본 클래스가 특정 인터페이스를 구현하지 않았더라도, CGLIB를 사용하면 프록시 객체에 해당 인터페이스를 구현하도록 추가할 수 있습니다.

### **3. 런타임에서의 동적 바인딩**
- 프록시 객체가 생성될 때, AOP 프레임워크는 런타임에 필요한 인터페이스를 추가로 구현하도록 프록시 객체를 구성합니다. 이로 인해 원본 클래스가 직접 구현하지 않은 인터페이스라도, 프록시 객체를 통해 해당 인터페이스로의 캐스팅이 가능해집니다.
- 예를 들어, `MyService` 클래스가 `Lockable` 인터페이스를 구현하지 않았더라도, 프록시 객체가 생성될 때 이 인터페이스를 구현하도록 설정된다면, `MyService` 객체를 `Lockable`로 캐스팅할 수 있게 됩니다.

### **4. 구체적인 동작 예시**
- 원본 클래스 `MyService`가 `Lockable` 인터페이스를 구현하지 않았더라도, 프록시 객체는 이 인터페이스를 구현할 수 있습니다.
- 프록시 객체가 `Lockable` 인터페이스를 구현하고 있으므로, 클라이언트 코드에서는 `MyService` 객체를 `Lockable` 인터페이스로 캐스팅하여 `lock()`, `unlock()` 등의 메서드를 호출할 수 있습니다.

### **5. 요약**
어드바이스된 객체가 특정 인터페이스로 캐스팅이 가능한 이유는 **AOP 프록시 객체가 해당 인터페이스를 동적으로 구현**하기 때문입니다. 이는 JDK 동적 프록시 또는 CGLIB 프록시와 같은 기술을 통해 구현되며, 이를 통해 런타임 시에 원본 객체가 아닌 프록시 객체가 추가된 인터페이스의 메서드를 제공할 수 있게 됩니다. 결과적으로, 클라이언트 코드에서는 원본 객체를 해당 인터페이스로 캐스팅하여 사용할 수 있습니다.