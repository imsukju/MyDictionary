리눅스 파일 시스템인 **ext3**에서 "dirty bit"는 파일 시스템이 현재 깨끗하게 마운트되어 있는지, 아니면 비정상적으로 마운트 해제되었는지를 표시하는 플래그입니다. 파일 시스템을 마운트하고 있는 동안, dirty bit는 설정되어 파일 시스템이 사용 중임을 나타냅니다. 이 비트가 설정된 상태에서 시스템이 비정상적으로 종료되거나 강제 종료되는 경우, 다음 부팅 시 파일 시스템이 완전히 일관성이 없는 상태일 수 있으므로 체크가 필요합니다.
ext3는 저널링 파일 시스템으로, 파일 시스템이 비정상적으로 종료되더라도 저널을 통해 파일 시스템의 복구를 지원합니다. dirty bit는 이런 상황에서 중요한 역할을 하는데, 파일 시스템이 올바르게 마운트 해제되었는지 여부를 판단하기 위해 이 비트를 참조하기 때문입니다.
### dirty bit의 동작 방식
1. **파일 시스템이 마운트될 때**: dirty bit가 설정됩니다.
2. **정상적인 파일 시스템 해제**: 파일 시스템이 마운트 해제될 때 dirty bit가 해제됩니다. 이는 파일 시스템이 깨끗하고 일관성이 있음을 나타냅니다.
3. **비정상적인 시스템 종료**: 파일 시스템이 제대로 마운트 해제되지 않으면 dirty bit가 여전히 설정된 상태로 남게 됩니다. 이는 다음 부팅 시 파일 시스템이 손상되었을 가능성이 있음을 의미하므로 `fsck`와 같은 도구가 이를 검출하고, 필요시 복구 절차를 수행합니다.
dirty bit를 이용한 이러한 관리 메커니즘 덕분에 ext3 파일 시스템은 데이터 손실을 줄이고 파일 시스템의 일관성을 보장할 수 있습니다.





9:47
ext3 파일 시스템에서 **dirty bit**는 파일 시스템 전체의 상태를 나타내는 플래그이지, 개별 파일에 대한 상태를 직접적으로 추적하지는 않습니다. 즉, 파일 시스템 수준에서 비정상적인 마운트 해제나 오류 여부를 감지하는 데 사용되지만, 특정 파일의 변경 사항에 대한 dirty bit는 별도로 존재하지 않습니다.
개별 파일의 변경 사항은 **페이지 캐시**에서 관리됩니다. 운영체제는 파일을 메모리로 읽어들일 때 페이지 캐시에 파일 데이터를 저장하고, 해당 페이지가 수정되면 해당 페이지가 **더티 페이지(Dirty Page)**로 표시됩니다. 이 더티 페이지는 나중에 디스크에 기록되어 파일의 변경 사항을 영구적으로 반영하게 됩니다.
따라서:
1. **파일 시스템 수준의 dirty bit**: 파일 시스템 전체가 일관성 있게 마운트 해제되었는지 여부를 나타냅니다.
2. **파일 변경 사항**: 개별 파일에 대한 변경 사항은 파일 시스템의 더티 비트가 아니라 페이지 캐시의 더티 페이지로 관리됩니다.
즉, ext3 파일 시스템은 개별 파일에 대해 더티 비트를 설정하지 않고, 변경된 파일의 데이터는 페이지 캐시에서 더티 페이지로 관리된 후 주기적으로 디스크에 반영됩니다.
9:48
리눅스 파일 시스템에서 **메모리에 변경된 파일 내용을 디스크에 쓰는 주기**는 **커널의 페이지 캐시**와 관련된 여러 설정에 의해 결정됩니다. 일반적으로 변경된 페이지(즉, **더티 페이지**)는 시스템이 비동기적으로 주기적으로 디스크에 기록됩니다. 이 주기는 다음과 같은 설정에 따라 달라집니다:
1. **`dirty_writeback_centisecs`**:
   이 매개변수는 **더티 페이지를 디스크에 쓰는 주기**를 정의합니다. 기본값은 일반적으로 5000(즉, 5초)로 설정되어 있으며, 이는 커널이 매 5초마다 백그라운드에서 더티 페이지를 디스크로 기록하게 됩니다.
2. **`dirty_expire_centisecs`**:
   이 설정은 더티 페이지가 일정 시간이 지난 후 기록될 수 있도록 허용하는 기준을 나타냅니다. 기본값은 30,000(즉, 30초)로 설정되어 있으며, 30초 이상 더티 상태로 유지된 페이지는 디스크에 기록할 대상으로 간주됩니다.
3. **`dirty_ratio`와 `dirty_background_ratio`**:
   - **`dirty_ratio`**는 시스템 메모리에서 더티 페이지가 차지하는 최대 비율을 의미합니다. 예를 들어, 이 값이 20으로 설정되어 있다면 시스템 메모리의 20%가 더티 페이지로 차 있을 때 강제로 디스크에 기록됩니다.
   - **`dirty_background_ratio`**는 백그라운드에서 더티 페이지를 디스크로 기록하기 시작하는 임계값입니다. 예를 들어, 이 값이 10으로 설정되어 있다면 메모리의 10%가 더티 페이지일 때 백그라운드에서 자동으로 쓰기 작업이 시작됩니다.
### 기본적인 작동 방식
- 변경된 파일의 데이터는 먼저 **메모리의 페이지 캐시**에 저장됩니다.
- 커널은 **주기적으로** 또는 **임계 상태(더티 페이지가 메모리의 일정 비율을 넘는 경우)**가 되면 해당 데이터를 디스크에 쓰는 과정을 거칩니다.
- 주로 백그라운드에서 이루어지므로 사용자는 이 쓰기 작업이 비동기적으로 이루어짐을 느끼지 못합니다. 그러나 데이터의 일관성을 보장하려면 **`fsync()`**와 같은 호출을 통해 변경된 데이터를 강제로 디스크에 기록할 수 있습니다.
이러한 설정은 `/proc/sys/vm/` 디렉터리에서 확인하거나 조정할 수 있습니다:
```bash
cat /proc/sys/vm/dirty_writeback_centisecs
cat /proc/sys/vm/dirty_expire_centisecs
```
### 요약:
- **매 5초** 주기로 백그라운드에서 더티 페이지를 디스크에 기록합니다(기본 설정).
- **30초 이상** 더티 상태로 유지된 페이지는 디스크로 기록됩니다.
- 메모리의 더티 페이지가 **10%**(또는 설정된 임계값) 이상 차면 백그라운드에서 쓰기가 시작됩니다.
9:48
네, `write()` 함수 자체는 데이터를 디스크에 바로 기록하는 옵션을 제공하지 않지만, 특정 파일에 대한 쓰기 동작을 제어하는 기능은 **`O_SYNC`** 또는 **`O_DSYNC`** 파일 열기 플래그와 같은 옵션을 통해 제어할 수 있습니다. 이 플래그들은 파일을 열 때 설정하며, 이후의 `write()` 호출에서 데이터를 바로 디스크에 기록하는 효과를 냅니다.
### 주요 옵션:
1. **`O_SYNC`**:
   - 파일을 열 때 이 플래그를 사용하면 **`write()` 호출 시 데이터를 디스크로 즉시 동기화**합니다. 이 경우, 데이터뿐만 아니라 **메타데이터(예: 파일 크기, 수정 시간 등)**도 디스크에 기록됩니다.
   - 즉, `write()` 호출이 반환되기 전에 해당 데이터와 관련된 모든 메타데이터가 디스크에 완전히 기록된 것이 보장됩니다.
   예시:
   ```c
   int fd = open("file.txt", O_WRONLY | O_SYNC);
   write(fd, data, size);
   ```
2. **`O_DSYNC`**:
   - `O_DSYNC`는 `O_SYNC`와 유사하지만, **데이터만을 동기화**합니다. 즉, 파일의 메타데이터는 동기화되지 않고 데이터만 디스크에 기록됩니다.
   - 파일의 크기나 타임스탬프와 같은 메타데이터보다 데이터 무결성이 중요할 때 유용합니다.
   예시:
   ```c
   int fd = open("file.txt", O_WRONLY | O_DSYNC);
   write(fd, data, size);
   ```
3. **`fdatasync()`**:
   - 이 함수는 `fsync()`와 유사하지만, **메타데이터를 제외한 파일 데이터**만 디스크에 기록합니다. `O_DSYNC`와 비슷한 효과를 가지고 있으며, 메타데이터 변경이 중요하지 않은 경우 사용할 수 있습니다.
   ```c
   fdatasync(fd);
   ```
### `fsync()`와의 차이점
- **`fsync()`**는 파일을 열 때 어떤 옵션을 설정하지 않더라도, 명시적으로 호출하면 해당 파일에 대한 데이터를 디스크에 동기화합니다. 반면, **`O_SYNC`** 또는 **`O_DSYNC`**는 파일을 열 때부터 동기화를 적용합니다.
- **`O_SYNC`**, **`O_DSYNC`** 플래그를 사용하면 각 `write()` 호출마다 디스크 동기화가 이루어지므로 성능에 더 큰 영향을 미칠 수 있습니다. **`fsync()`**는 필요할 때만 호출할 수 있어 유연성이 있습니다.
### 요약:
- **`O_SYNC`**: `write()` 호출 시 데이터와 메타데이터를 즉시 디스크에 동기화.
- **`O_DSYNC`**: `write()` 호출 시 데이터만 디스크에 동기화.
- **`fsync()`**, **`fdatasync()`**: 명시적으로 호출하여 파일의 데이터(및 선택적으로 메타데이터)를 디스크에 기록.