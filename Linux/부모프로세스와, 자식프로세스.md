### **부모 프로세스와 자식 프로세스: 기초부터 상세 설명**

---

### 1. **프로세스란 무엇인가?**

- **프로세스**: 실행 중인 프로그램의 인스턴스.
    - 프로그램은 하드디스크에 저장된 실행 파일(정적 상태).
    - 프로세스는 메모리에 적재되어 실행 중인 상태(동적 상태).

### 프로세스의 특징:

1. **PID (Process ID)**:
    - 운영체제가 프로세스를 고유하게 식별하기 위해 부여하는 번호.
2. **PPID (Parent Process ID)**:
    - 프로세스를 생성한 부모 프로세스의 ID.
3. **독립된 메모리 공간**:
    - 각 프로세스는 고유한 메모리 공간(코드, 데이터, 힙, 스택)을 가짐.
4. **병렬 실행**:
    - 다수의 프로세스가 동시에 실행 가능.

---

### 2. **부모 프로세스와 자식 프로세스란?**

### **2.1 부모 프로세스란?**

- 새로운 프로세스를 생성한 **기존 프로세스**.
- 모든 프로세스는 기존 프로세스(부모 프로세스)에 의해 생성됨.
- 예외: **init 프로세스(PID 1)**:
    - 시스템 부팅 시 생성되는 첫 프로세스.
    - 모든 프로세스의 "조상 프로세스".

### **2.2 자식 프로세스란?**

- 부모 프로세스에 의해 생성된 **새로운 프로세스**.
- 부모의 실행 환경을 복사하여 시작하지만, 독립적으로 실행.
- 고유한 PID와 PPID를 가짐.

### **2.3 부모-자식 관계의 예**

- 예: `bash`에서 `ls` 명령 실행
    - 부모 프로세스: `bash` (쉘 프로세스)
    - 자식 프로세스: `ls` 실행 파일을 실행하는 프로세스

---

### 3. **프로세스 생성 원리: `fork()` 시스템 호출**

### **3.1 `fork()`란?**

- 부모 프로세스를 복제하여 **새로운 자식 프로세스**를 생성하는 시스템 호출.
- 부모 프로세스와 동일한 메모리 구조를 가진 자식 프로세스가 생성됨.

### **3.2 `fork()`의 특징**

1. **독립적 실행**:
    - 자식 프로세스는 부모의 복사본이지만, 이후에는 독립적으로 실행.
2. **PID와 PPID**:
    - 자식 프로세스는 새로운 PID를 할당받음.
    - 자식의 PPID는 부모 프로세스의 PID.
3. **메모리 복사**:
    - 자식 프로세스는 부모의 코드, 데이터, 힙, 스택을 복사.
    - 메모리 상에서 독립적으로 동작.

### **3.3 `fork()` 동작 예시**

- 부모 프로세스가 `fork()`를 호출하면:
    1. 자식 프로세스가 생성.
    2. 부모 프로세스는 `fork()` 호출에서 **자식의 PID**를 반환받음.
    3. 자식 프로세스는 `fork()` 호출에서 **0**을 반환받음.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork(); // 새로운 자식 프로세스 생성
    if (pid == 0) {
        // 자식 프로세스 실행
        printf("This is the child process. PID: %d\n", getpid());
    } else {
        // 부모 프로세스 실행
        printf("This is the parent process. Child PID: %d\n", pid);
    }
    return 0;
}

```

---

### 4. **자식 프로세스의 실행: `exec()` 시스템 호출**

### **4.1 `exec()`란?**

- 자식 프로세스가 기존 프로그램을 새로운 프로그램으로 대체.
- 메모리 상의 코드, 데이터, 스택, 힙이 새 프로그램으로 교체.

### **4.2 `exec()` 동작 과정**

1. 부모 프로세스가 `fork()`로 자식 프로세스 생성.
2. 자식 프로세스가 `exec()` 호출:
    - 하드디스크에서 실행 파일을 메모리로 로드.
    - 새로운 프로그램 실행 시작.

### **4.3 예: 쉘에서 `ls` 실행**

1. 사용자가 쉘에서 `ls` 명령 입력.
2. 쉘이 `fork()` 호출:
    - 자식 프로세스 생성.
3. 자식 프로세스가 `exec()` 호출:
    - `ls` 실행 파일(`/usr/bin/ls`)을 로드하고 실행.

---

### 5. **부모-자식 프로세스의 메모리 구조**

### **5.1 메모리 구조 개요**

1. **코드 섹션 (Text Segment)**:
    - 실행 중인 프로그램의 기계어 코드가 저장.
    - 부모와 자식이 공유.
2. **데이터 섹션 (Data Segment)**:
    - 전역 변수와 정적 변수.
    - 부모와 자식은 독립적으로 동작.
3. **힙 (Heap)**:
    - 동적 메모리 할당 영역.
    - 복사되지만 부모와 자식은 독립적으로 동작.
4. **스택 (Stack)**:
    - 함수 호출과 지역 변수 저장.
    - 복사되지만 부모와 자식은 독립적으로 동작.

---

### 6. **부모와 자식의 실행 흐름**

1. **부모 프로세스**:
    - 계속 실행하며 자식 프로세스의 종료 상태를 기다릴 수 있음.
2. **자식 프로세스**:
    - 독립적으로 실행되며 종료 시 운영체제에 의해 자원 회수.

### **예: 부모-자식 프로세스 실행 흐름**

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 자식 프로세스
        printf("Child process running...\n");
        sleep(2);
        printf("Child process exiting...\n");
    } else {
        // 부모 프로세스
        printf("Parent process waiting for child...\n");
        wait(NULL); // 자식 프로세스 종료 대기
        printf("Child process finished.\n");
    }

    return 0;
}

```

출력 예시:

```bash
Parent process waiting for child...
Child process running...
Child process exiting...
Child process finished.

```

---

### 7. **부모 프로세스가 종료되면?**

- **고아 프로세스(Orphan Process)**:
    - 부모 프로세스가 종료되었지만, 자식 프로세스는 여전히 실행 중인 상태.
    - 고아 프로세스는 `init` 프로세스(PID 1)가 관리.
- **좀비 프로세스(Zombie Process)**:
    - 자식 프로세스가 종료되었지만, 부모가 종료 상태를 수집하지 않은 상태.
    - 좀비 프로세스는 메모리를 차지하지 않지만, 프로세스 테이블에서 PID를 유지.

---

### 8. **질문 요약**

- **부모 프로세스란?**
    - 새로운 프로세스를 생성한 기존 프로세스.
    - 예: 쉘(`bash`)이 부모 프로세스.
- **자식 프로세스란?**
    - 부모 프로세스가 `fork()`로 생성한 새로운 프로세스.
    - 예: 쉘이 `ls` 명령 실행을 위해 생성한 프로세스.
- **`fork()`와 `exec()`의 관계**:
    - `fork()`: 부모 프로세스를 복제하여 자식 프로세스 생성.
    - `exec()`: 자식 프로세스가 새로운 프로그램을 실행.
- **부모-자식 관계의 중요성**:
    - 운영체제의 멀티태스킹을 가능하게 함.
    - 모든 프로세스는 부모 프로세스로부터 생성되어 상호 연결.