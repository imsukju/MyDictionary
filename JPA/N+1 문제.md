N+1 문제는 JPA(Hibernate)와 같은 ORM(Object-Relational Mapping) 프레임워크에서 발생할 수 있는 성능 문제로, 데이터베이스의 효율적인 쿼리 실행을 방해하여 성능 저하를 유발합니다. 이 문제를 이해하려면, 기본적인 ORM과 데이터베이스 연관 관계에 대해 알아야 합니다.

### N+1 문제의 개념

N+1 문제는 주로 **지연 로딩(Lazy Loading)** 전략을 사용할 때 발생합니다. JPA에서 엔티티 간의 연관 관계를 처리할 때, 하나의 엔티티를 조회할 때 그와 관련된 다른 엔티티들을 지연 로딩하는 방식이 기본 설정입니다. 이때 N+1 문제는 다음과 같은 방식으로 발생합니다.

1. **메인 엔티티 조회 (1번 쿼리)**: 예를 들어, `Member` 엔티티가 있고 `Member`는 여러 `Order` 엔티티와 연관되어 있습니다. 이때 `Member` 엔티티를 조회하면 기본적으로 연관된 `Order` 엔티티들은 로딩되지 않고, 대신 프록시 객체가 반환됩니다.
   
   ```sql
   SELECT * FROM Member;
   ```

   이때 데이터베이스로부터 모든 `Member` 데이터가 로드됩니다. 여기까지는 문제가 없습니다.

2. **연관된 엔티티 조회 (N번 쿼리)**: 이제 각 `Member`의 연관된 `Order` 엔티티에 접근할 때마다 별도의 쿼리가 발생합니다. 예를 들어, 각 `Member`의 `Order`를 조회하려고 하면, `N`개의 `Member`에 대해 각각 `Order` 조회 쿼리가 추가로 발생합니다.

   ```sql
   SELECT * FROM Order WHERE member_id = 1;
   SELECT * FROM Order WHERE member_id = 2;
   ...
   SELECT * FROM Order WHERE member_id = N;
   ```

이 과정에서 발생하는 문제는, 처음 `Member` 조회 쿼리 1개 외에, `Order` 조회 쿼리가 `N`번 더 실행되어 총 `N+1`개의 쿼리가 실행된다는 점입니다. 만약 `Member`가 100명이라면 1번의 `Member` 조회 쿼리와 100번의 `Order` 조회 쿼리가 발생하여 총 101개의 쿼리가 실행됩니다.

### N+1 문제의 성능 저하

이처럼 쿼리 개수가 기하급수적으로 증가하기 때문에, 대규모 데이터를 처리할 때는 성능이 크게 저하됩니다. 작은 데이터셋에서는 성능 차이가 미미할 수 있지만, 데이터가 많아지면 응답 시간이 매우 느려질 수 있습니다. 즉, 다수의 쿼리 호출로 인해 네트워크 지연 시간, 데이터베이스 부하가 급격히 증가합니다.

### 결론

N+1 문제는 JPA에서 성능 최적화를 위해 반드시 해결해야 하는 문제 중 하나입니다. 주로 **지연 로딩**과 연관 관계에서 발생하는 이 문제는 Fetch Join, `@EntityGraph`, Batch Fetch 등을 통해 해결할 수 있습니다. 시스템의 성능을 극대화하기 위해 쿼리 발생 패턴을 잘 이해하고 최적화 전략을 적절히 적용하는 것이 중요합니다.


### N+1 문제 해결 방안

N+1 문제는 ORM(Object Relational Mapping) 기술을 사용할 때 자주 발생하는 성능 이슈입니다. 대규모 데이터베이스에서의 성능 최적화는 시스템의 전반적인 효율성을 좌우하므로, N+1 문제를 제대로 이해하고 해결하는 것이 매우 중요합니다. 이번 섹션에서는 N+1 문제를 해결하는 다양한 방법을 깊이 있게 설명하고, 각각의 방법이 어떻게 문제를 해소할 수 있는지 살펴보겠습니다.

#### 1. Fetch Join 사용
Fetch Join은 N+1 문제를 해결하는 가장 기본적이면서도 효과적인 방법입니다. 기본적으로 JPA에서 연관된 엔티티를 조회할 때, 각 엔티티를 개별적으로 조회하는 방식(Lazy Loading)은 다수의 추가 쿼리를 발생시키는데, Fetch Join을 사용하면 연관된 엔티티를 한 번에 가져올 수 있습니다.

##### 1.1 JPQL에서 Fetch Join 사용

```java
SELECT m FROM Member m JOIN FETCH m.orders;
```

이 쿼리는 `Member` 엔티티와 그에 연관된 모든 `Order` 엔티티를 한 번의 쿼리로 가져옵니다. 일반적으로 `Member` 엔티티만 조회한 후 각 `Order`를 개별 쿼리로 조회하는 N+1 문제가 발생하는데, Fetch Join은 이를 해결해줍니다.

예를 들어, 100명의 회원이 각각 여러 개의 주문을 가지고 있을 때, 기본 설정에서는 1개의 `Member` 조회 쿼리와 100개의 `Order` 조회 쿼리가 실행되므로 총 101개의 쿼리가 발생합니다. 하지만 Fetch Join을 사용하면 다음과 같이 단 1개의 쿼리만 실행됩니다.

```sql
SELECT m.*, o.* 
FROM Member m 
JOIN Order o 
ON m.id = o.member_id;
```

##### 1.2 장점과 단점
- **장점**: Fetch Join은 매우 강력한 도구입니다. 한 번의 쿼리로 다수의 연관된 데이터를 로드할 수 있어 성능이 크게 향상됩니다.
- **단점**: Fetch Join은 모든 연관된 엔티티를 무조건 가져오기 때문에, 대량의 데이터를 다룰 때는 메모리 과부하를 일으킬 수 있습니다. 또한, Fetch Join은 기본적으로 SQL 조인을 사용하므로, 잘못 사용하면 데이터 중복 문제가 발생하거나 예상치 못한 결과를 초래할 수 있습니다.

#### 2. @EntityGraph 사용
[엔티티 그래프 자세한 설명](./Tip/Tip4_엔티티%20그래프.md)
`@EntityGraph`는 JPA에서 엔티티를 조회할 때 연관된 엔티티를 함께 로드할 수 있는 방법입니다. Fetch Join과 비슷한 방식으로 작동하지만, 쿼리와는 무관하게, 애플리케이션 코드 내에서 선언적으로 연관 관계를 설정할 수 있습니다. 즉, 특정 상황에서만 Fetch 전략을 변경하고 싶을 때 유용합니다.

##### 2.1 @EntityGraph 적용 예시

```java
@EntityGraph(attributePaths = {"orders"})
List<Member> findAll();
```

이 코드는 `Member` 엔티티와 연관된 `Order` 엔티티를 즉시 로딩합니다. 따라서, 모든 `Member` 엔티티를 조회할 때, `Order`도 함께 한 번에 가져옵니다. N+1 문제를 해결하면서도, 필요에 따라 Fetch 전략을 조정할 수 있는 유연성을 제공합니다.

##### 2.2 장점과 단점
- **장점**: Fetch Join과 달리 `@EntityGraph`는 JPQL이나 쿼리 DSL과 분리되어 동작하기 때문에, 코드에서 더 유연하게 사용할 수 있습니다. 이를 통해 특정 상황에서만 연관된 엔티티를 로딩하는 방식으로 N+1 문제를 해결할 수 있습니다.
- **단점**: 쿼리 실행에 대한 세부적인 제어가 어렵고, 성능을 최적화하려면 데이터베이스 테이블 구조와 연관 엔티티 간의 관계를 잘 파악해야 합니다. 또한, 엔티티 간의 복잡한 연관 관계를 처리할 때는 예상치 못한 결과를 초래할 수 있습니다.

#### 3. Batch Size 설정

`Batch Size` 설정은 JPA에서 제공하는 또 다른 성능 최적화 기법으로, 다수의 연관 엔티티를 한 번에 일괄 처리할 수 있도록 돕습니다. 기본적으로 지연 로딩을 사용할 때, 각각의 엔티티에 대해 개별 쿼리가 실행되지만, Batch Size를 설정하면 여러 개의 연관 엔티티를 한 번에 가져오는 방식으로 N+1 문제를 완화할 수 있습니다.

##### 3.1 Batch Size 설정 방법

```properties
spring.jpa.properties.hibernate.default_batch_fetch_size=100
```

이 설정은 한 번에 100개의 엔티티를 일괄로 가져오도록 하는 설정입니다. 예를 들어, 100명의 회원에 대해 각 회원의 주문을 조회할 때, 기본 설정에서는 100번의 개별 쿼리가 실행되겠지만, Batch Size 설정을 적용하면 한 번에 100개의 `Order`를 가져오는 쿼리로 변환됩니다.

##### 3.2 장점과 단점
- **장점**: 쿼리 수를 크게 줄일 수 있어 네트워크 및 데이터베이스 부하를 줄일 수 있습니다. 또한, Fetch Join과는 달리 연관된 엔티티의 로딩 시점을 지연 로딩으로 유지할 수 있어, 불필요한 데이터를 미리 로드하지 않습니다.
- **단점**: 너무 큰 Batch Size 값을 설정하면 한 번에 가져오는 데이터 양이 많아져 오히려 성능이 저하될 수 있습니다. 적절한 Batch Size 값은 데이터베이스와 서버 환경에 따라 다르므로, 충분한 테스트를 통해 값을 결정해야 합니다.

#### 4. 즉시 로딩(Eager Loading) 사용

즉시 로딩은 지연 로딩과는 반대로, 연관된 엔티티를 조회할 때 무조건 함께 로딩하는 방식입니다. 이렇게 하면 N+1 문제는 발생하지 않지만, 모든 연관 데이터를 무조건 가져오기 때문에 필요한 경우에만 신중하게 사용해야 합니다.

##### 4.1 즉시 로딩 적용 예시

```java
@ManyToOne(fetch = FetchType.EAGER)
private Order order;
```

이 코드는 `Order` 엔티티가 `Member` 엔티티와 연관될 때, 항상 `Order`를 즉시 로딩하도록 설정하는 방식입니다. 기본적으로 JPA는 연관 관계를 지연 로딩으로 설정하지만, 즉시 로딩을 사용하면 N+1 문제를 방지할 수 있습니다.

##### 4.2 장점과 단점
- **장점**: 즉시 로딩을 사용하면 N+1 문제를 근본적으로 제거할 수 있습니다. 연관된 엔티티가 항상 필요하다면 성능 상의 이점이 있을 수 있습니다.
- **단점**: 즉시 로딩은 필요하지 않은 데이터를 미리 로드할 수 있기 때문에, 메모리 사용량이 증가하고, 불필요한 쿼리가 발생할 수 있습니다. 연관된 엔티티가 복잡하거나 데이터 양이 많을 경우 성능이 오히려 저하될 수 있습니다.

#### 5. Subquery 활용

때때로 복잡한 N+1 문제는 SQL 서브쿼리(Subquery)를 사용하여 해결할 수 있습니다. 서브쿼리는 메인 쿼리 내부에서 연관된 엔티티의 데이터를 미리 필터링하여 필요할 때만 데이터를 가져오는 방식입니다. 그러나 이 방법은 JPA가 자동으로 처리하지 않기 때문에, 필요 시 직접 SQL을 작성해야 합니다.

##### 5.1 서브쿼리 예시

```sql
SELECT m.*, (SELECT COUNT(*) FROM Order o WHERE o.member_id = m.id) AS order_count
FROM Member m;
```

이 쿼리는 `Member` 엔티티와 연관된 `Order`의 개수를 한 번에 계산합니다. 이를 통해 추가적인 `Order` 조회를 최소화할 수 있습니다.

##### 5.2 장점과 단점
- **장점**: 서브쿼리를 사용하면 특정 상황에 맞게 최적화된 쿼리를 작성할 수 있으며, 다수의 연관 데이터를 한 번에 처리할 수 있습니다.
- **단점**: 서브쿼리는 복잡한 SQL 문법을 요구하며, JPA에서 제공하는 표준 방법과는 다르게 데이터베이스 종속적인 코드가 될 수 있습니다. 서브쿼리의 성능은 데이터베이스에 따라 다를 수 있으며, 잘못된 서브쿼리 사용은 오히려 성능 저하를 초래할 수 있습니다.

---

### 결론

N+1 문제는 데이터베이스와 애플리케이션 간의 연관 관계를 최적화하는 데 중요한 이슈입니다. 이를 해결하기 위해 다양한 방법을 사용할 수 있으며, 각 방법은 상황에 따라 장단점이 있습니다. **Fetch Join**은 가장 기본적이고 직관적인 해결 방법이며, **Batch Size** 설정은 지연 로딩을 유지하면서도 성능을 향상시킬 수 있는

 좋은 도구입니다. 또한 **@EntityGraph**와 **즉시 로딩**은 특정 상황에서 효과적으로 사용할 수 있는 옵션입니다.

N+1 문제를 해결하기 위해서는 애플리케이션의 데이터 패턴과 데이터베이스 성능을 충분히 고려한 후 적절한 전략을 선택하는 것이 중요합니다.